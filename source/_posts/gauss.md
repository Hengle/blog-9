---
title: 屏幕后处理效果
mathjax: true
date: 2019-03-25 14:26:33
tags:
    Unity
categories: "Unity Shader"
---
屏幕后处理，通常指的是在渲染整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深（Depth of Field）、运动模糊（Motion Blur）等。
因此，想要实现屏幕后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，而Unity为我们提供了这样一个方便的接口，OnRenderImage函数。它的函数声明如下：
```C#
void OnRenderImage(RenderTexture src, RenderTexture dest)
```
当我们在脚本中声明此函数后，Unity会把当前渲染得到的图像存储在第一个参数对应的渲染纹理中，通过函数的一系列操作后，在把目标渲染纹理，即第二个桉树对应的渲染纹理显示到屏幕上。在OnRenderImage函数中，我们通常是利用Graphics.Blit函数来完成对渲染纹理处理。它有3中函数声明：
```C#
namespace UnityEngine
{
    public class Graphics
    {
        public static void Blit(Texture src, RenderTexture dest);
        public static void Blit(Texture source, RenderTexture dest, int sourceDepthSlice, int destDet\pthSlice);
        public static void Blit(Texture src, RenderTexture dest, Material mat, int pass, int destDepthSlice);
        public static void Blit(Texture src, Material mat);
    }
}
```
其中，参数src对应了源纹理，在屏幕后处理技术中，这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理。参数dest是目标渲染纹理，如果它的值为null就会直接将结果显示在屏幕上。参数mat是我们使用的材质，这个材质使用的Unity Shader将会进行各种屏幕后处理操作，而src纹理将会被传递给Shader中名为_MainText的纹理属性。参数pass的默认值为-1，表示将会依次调用Shader内的所有Pass。否则，只会调用给定索引的Pass。
在默认情况下，OnRenderImage函数会在所有的不透明和透明的Pass执行完毕后调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的Pass（即渲染队列小于等于2500的Pass，内置的Background，Geometry和AlphaTest渲染队列均在此范围内）执行完毕后立即调用OnRenderImage函数，从而不对透明物体产生任何影响。此时，我们可以在OnRenderImage函数钱添加ImageEffectOpaque属性来实现这样的目的。
因此，要在Unity中实现屏幕后处理效果，过程通常如下：我们首先需要在摄像机中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现OnRenderImage函数来获取当前屏幕的渲染纹理。然后，再调用Graphics.Blit函数使用特定的Unity Shader来对当前图像进行处理，在把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用Graphics.Blit函数来对上一步的输出结果进行下一步处理。

#### 卷积

在图像处理中，卷积操作指的是使用一个卷积核（kernel）一张图像中的每个像素进行一些列操作。卷积核通常是一个四方形网格结构，该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置于该像素上，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。

这样的过程虽然简单，但可以实现很多常见的图像处理效果，例如图像模糊、边缘检测等。

#### 常见的边缘检测算子

卷积操作的神奇之处在于选择的卷积核。那么，用于边缘检测的卷积核（也被称为边缘检测算子）应该张什么样呢？再回答这个问题前，我们可以首先回想一下边到底是如何形成的。如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，我们就会认为它们之间应该有一条编辑。这种相邻像素之间的差值可以用**梯度（gradient）**来表示，可以想想得到，边缘处的梯度绝对值会比较大。基于这样的理解，有几种不同的边缘检测算子被先后提出来。

Roberts
Gx{
    -1,0,   
     0,1, 
}
Gy{
    0,-1,
    1, 0,   
}

Prewitt
Gx
{
    -1,-1,-1,   
     0, 0, 0,
     1, 1, 1,
}
Gy
{
    -1, 0, 1,
    -1, 0, 1,
    -1, -, 1,
}

Sobel
Gx
{
    -1,-2,-1,
     0, 0, 0,
     1, 2, 1,
}
Gy
{
    -1, 0, 1,
    -2, 0, 2,
    -1, 0, 1,
}
3中常见的边缘检测算子，它们都包含了两个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。再进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值Gx和Gy，而整体的梯度可按下面的公式计算而得：

$$ G = \sqrt{G^2_x + G^2_y} $$ 

由于上述符号包含了开根号操作，出于性能考虑，我们有时会使用绝对值操作来代替开根号操作：

$$ G=|G_x|+|G_y| $$

当得到梯度后，我们就可以据此来判断哪些像素对应了边缘（梯度值越大，越有可能是边缘点）。
模式的实现有很多方法，例如均值模糊和中值模糊。均值模糊同样适用了卷积操作，它适用的卷积核中的各个元素值都相等，且相加等于1，也就是说，卷积后得到的像素值是其领域内各个像素值的平均值。而中值模式则是选择领域内对所有像素排序后的中值替换掉的颜色。一个更高级的模糊方法是高斯模糊。
# 高斯滤波
高斯模糊（Gaussian Blur），也叫高斯平滑，高斯滤波，其通常用它来减少图像噪声以及降低细节层次，尝尝也被用于对图像进行模糊。
通俗的讲，高斯模糊就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和领域内的其他像素经过加权平均后得到。高斯模糊的具体操作是：用一个模版（或称卷积、掩模）扫描图像中的每一个像素，用模版确定的领域内像素的加权平均灰度值去替代模版中心像素点的值。
高斯模糊同样利用了卷积计算，它适用了卷积核名为高斯核。高斯核是一个正方形大小的滤波器，其中每个元素的计算都是基于下面的高斯方程：
<font size="4">$G(x,y)= {1 \over 2\pi\delta^2}^{e^{x^2+y^2 \over 2\delta^2}}$</font>
其中，$\delta$是标准方差（一般取值为1），x和y分别对应了当前位置到卷积核中心的整数距离。要构建一个高斯核，我们只需要计算高斯核中各个位置对应的高斯值。为了保证滤波后的图像不会变暗，我们需要对高斯核中的权重进行归一化，既让每个权重除以所有权重的和，这样可以保证所有权重的和为1。因此，高斯函数中e前面的系数实际不会对结果有任何影响。
高斯方程很好地模拟了领域每个像素对当前处理像素的影响程度，距离越近，影响越大。
